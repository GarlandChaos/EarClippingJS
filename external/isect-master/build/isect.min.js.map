{"version":3,"file":"isect.min.js","sources":["../node_modules/splaytree/index.js","../src/geom.js","../src/sweepStatus.js","../src/SweepEvent.js","../sweep.js","../src/intersectSegments.js","../node_modules/flatbush/index.js","../src/createEventQueue.js","../brute.js","../bush.js"],"sourcesContent":["/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\n/**\n * @typedef {*} Key\n */\n\n\n/**\n * @typedef {*} Value\n */\n\n\n/**\n * @typedef {function(node:Node):void} Visitor\n */\n\n\n/**\n * @typedef {function(a:Key, b:Key):number} Comparator\n */\n\n\n/**\n * @param {function(node:Node):string} NodePrinter\n */\n\n\n/**\n * @typedef {Object}  Node\n * @property {Key}    Key\n * @property {Value=} data\n * @property {Node}   left\n * @property {Node}   right\n */\n\nclass Node {\n\n  constructor (key, data) {\n    this.key    = key;\n    this.data   = data;\n    this.left   = null;\n    this.right  = null;\n  }\n}\n\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n * @param {Key} i\n * @param {Node?} t\n * @param {Comparator} comparator\n */\nfunction splay (i, t, comparator) {\n  if (t === null) return t;\n  let l, r, y;\n  const N = new Node();\n  l = r = N;\n\n  while (true) {\n    const cmp = comparator(i, t.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        y = t.left;                           /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t;                               /* link right */\n      r = t;\n      t = t.left;\n    //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        y = t.right;                          /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t;                              /* link left */\n      l = t;\n      t = t.right;\n    } else {\n      break;\n    }\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\n\n/**\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}      root\n */\nfunction insert (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  tree._size++;\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\n\n/**\n * Insert i into the tree t, unless it's already there.\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}       root\n */\nfunction add (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    tree._size++;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp === 0) return t;\n  else {\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp > 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    tree._size++;\n    return node;\n  }\n}\n\n\n/**\n * Deletes i from the tree if it's there\n * @param {Key}        i\n * @param {Tree}       tree\n * @param {Comparator} comparator\n * @param {Tree}       tree\n * @return {Node}      new root\n */\nfunction remove (i, t, comparator, tree) {\n  let x;\n  if (t === null) return null;\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) {               /* found it */\n    if (t.left === null) {\n      x = t.right;\n    } else {\n      x = splay(i, t.left, comparator);\n      x.right = t.right;\n    }\n    tree._size--;\n    return x;\n  }\n  return t;                         /* It wasn't there */\n}\n\n\nfunction split (key, v, comparator) {\n  let left, right;\n  if (v === null) {\n    left = right = null;\n  } else {\n    v = splay(key, v, comparator);\n\n    const cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left  = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right   = v.right;\n      v.right = null;\n      left    = v;\n    } else {\n      left   = v.left;\n      v.left = null;\n      right  = v;\n    }\n  }\n  return { left, right };\n}\n\n\nfunction merge (left, right, comparator) {\n  if (right === null) return left;\n  if (left  === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Array<string>}               out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction printRow (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\n  }\n}\n\n\nexport default class Tree {\n\n  constructor (comparator = DEFAULT_COMPARE) {\n    this._comparator = comparator;\n    this._root = null;\n    this._size = 0;\n  }\n\n\n  /**\n   * Inserts a key, allows duplicates\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  insert (key, data) {\n    return this._root = insert(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Adds a key, if it is not present in the tree\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  add (key, data) {\n    return this._root = add(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  remove (key) {\n    this._root = remove(key, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    let node = this._root;\n    if (node) {\n      while (node.left) node = node.left;\n      this._root = splay(node.key,  this._root, this._comparator);\n      this._root = remove(node.key, this._root, this._comparator, this);\n      return { key: node.key, data: node.data };\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  findStatic (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return current;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  find (key) {\n    if (this._root) {\n      this._root = splay(key, this._root, this._comparator);\n      if (this._comparator(key, this._root.key) !== 0) return null;\n    }\n    return this._root;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Boolean}\n   */\n  contains (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return true;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return false;\n  }\n\n\n  /**\n   * @param  {Visitor} visitor\n   * @param  {*=}      ctx\n   * @return {SplayTree}\n   */\n  forEach (visitor, ctx) {\n    let current = this._root;\n    const Q = [];  /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !==  null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop();\n          visitor.call(ctx, current);\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range (low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns array of keys\n   * @return {Array<Key>}\n   */\n  keys () {\n    const keys = [];\n    this.forEach(({ key }) => keys.push(key));\n    return keys;\n  }\n\n\n  /**\n   * Returns array of all the data in the nodes\n   * @return {Array<Value>}\n   */\n  values () {\n    const values = [];\n    this.forEach(({ data }) => values.push(data));\n    return values;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  min() {\n    if (this._root) return this.minNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  max() {\n    if (this._root) return this.maxNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  minNode(t = this._root) {\n    if (t) while (t.left) t = t.left;\n    return t;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  maxNode(t = this._root) {\n    if (t) while (t.right) t = t.right;\n    return t;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    let current = this._root, done = false, i = 0;\n    const Q = [];\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = Q.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Node}   d\n   * @return {Node|null}\n   */\n  next (d) {\n    let root = this._root;\n    let successor = null;\n\n    if (d.right) {\n      successor = d.right;\n      while (successor.left) successor = successor.left;\n      return successor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) {\n        successor = root;\n        root = root.left;\n      } else root = root.right;\n    }\n\n    return successor;\n  }\n\n\n  /**\n   * @param  {Node} d\n   * @return {Node|null}\n   */\n  prev (d) {\n    let root = this._root;\n    let predecessor = null;\n\n    if (d.left !== null) {\n      predecessor = d.left;\n      while (predecessor.right) predecessor = predecessor.right;\n      return predecessor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) root = root.left;\n      else {\n        predecessor = root;\n        root = root.right;\n      }\n    }\n    return predecessor;\n  }\n\n\n  /**\n   * @return {SplayTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n\n  /**\n   * @return {NodeList}\n   */\n  toList() {\n    return toList(this._root);\n  }\n\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load (keys = [], values = [], presort = false) {\n    let size = keys.length;\n    const comparator = this._comparator;\n\n    // sort if needed\n    if (presort) sort(keys, values, 0, size - 1, comparator);\n\n    if (this._root === null) { // empty tree\n      this._root = loadRecursive(this._root, keys, values, 0, size);\n      this._size = size;\n    } else { // that re-builds the whole tree from two in-order traversals\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n      size = this._size + size;\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\n    }\n    return this;\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isEmpty() { return this._root === null; }\n\n  get size () { return this._size; }\n\n\n  /**\n   * @param  {NodePrinter=} printNode\n   * @return {String}\n   */\n  toString (printNode = (n) => n.key) {\n    const out = [];\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\n    return out.join('');\n  }\n\n\n  update (key, newKey, newData) {\n    const comparator = this._comparator;\n    let { left, right } = split(key, this._root, comparator);\n    this._size--;\n    if (comparator(key, newKey) < 0) {\n      right = insert(newKey, newData, right, comparator, this);\n    } else {\n      left = insert(newKey, newData, left, comparator, this);\n    }\n    this._root = merge(left, right, comparator);\n  }\n\n\n  split(key) {\n    return split(key, this._root, this._comparator);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction createList(keys, values) {\n  const head = { next: null };\n  let p = head;\n  for (let i = 0; i < keys.length; i++) {\n    p = p.next = { key: keys[i], data: values[i] };\n  }\n  p.next = null;\n  return head.next;\n}\n\n\nfunction toList (root) {\n  var current = root;\n  var Q = [], done = false;\n\n  const head = { next: null };\n  let p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop();\n        current = current.right;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next;\n}\n\n\nfunction sortedListToBST(list, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const left = sortedListToBST(list, start, middle);\n\n    const root = list.head;\n    root.left = left;\n\n    list.head = list.head.next;\n\n    root.right = sortedListToBST(list, middle + 1, end);\n    return root;\n  }\n  return null;\n}\n\n\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\n  const head = {}; // dummy\n  let p = head;\n\n  let p1 = l1;\n  let p2 = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next;\n    } else {\n      p.next = p2;\n      p2 = p2.next;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null)      p.next = p1;\n  else if (p2 !== null) p.next = p2;\n\n  return head.next;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","/**\n * Just a collection of geometry related utilities\n */\n\n// This is used for precision checking (e.g. two numbers are equal\n// if their difference is smaller than this number). The value is \n// chosen empirically. We still may run into precision related issues.\n// TODO: we should allow consumers to configure this.\nexport const EPS = 1e-9;//10;\n\nexport function getIntersectionXPoint(segment, xPos, yPos) {\n  var dy1 = segment.from.y - yPos;\n  var dy2 = yPos - segment.to.y;\n  var dy = segment.to.y - segment.from.y;\n  if (Math.abs(dy1) < EPS) {\n    // The segment starts on the sweep line\n    if (Math.abs(dy) < EPS) {\n      // the segment is horizontal. Intersection is at the point\n      if (xPos <= segment.from.x) return segment.from.x;\n      if (xPos > segment.to.x) return segment.to.x;\n      return xPos;\n    }\n    return segment.from.x;\n  }\n  \n  var dx = (segment.to.x - segment.from.x); \n  var xOffset; \n  if (dy1 >= dy2) {\n    xOffset = dy1 * (dx / dy); \n    return (segment.from.x - xOffset);\n  } \n  xOffset = dy2 * (dx / dy);\n  return (segment.to.x + xOffset);\n}\n\nexport function angle(dx, dy) {\n  // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle\n  var p = dx/(Math.abs(dx) + Math.abs(dy)) // -1 .. 1 increasing with x\n\n  if (dy < 0) return p - 1;  // -2 .. 0 increasing with x\n  return 1 - p               //  0 .. 2 decreasing with x\n}\n\nexport function intersectSegments(a, b) {\n  //  https://stackoverflow.com/a/1968345/125351\n  var aStart = a.from, bStart = b.from;\n  var p0_x = aStart.x, p0_y = aStart.y,\n      p2_x = bStart.x, p2_y = bStart.y;\n\n  var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;\n  var div = s1_x * s2_y - s2_x * s1_y;\n\n  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;\n  if (s < 0 || s > 1) return;\n\n  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;\n\n  if (t >= 0 && t <= 1) {\n    return {\n      x: p0_x - (t * s1_x),\n      y: p0_y - (t * s1_y)\n    }\n  }\n}\n\nexport function same(x0, x1, y0, y1) {\n  return Math.abs(x0 - x1) < EPS && Math.abs(y0 - y1) < EPS;\n}\n\nexport function samePoint(a, b) {\n  return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;\n}\n","import SplayTree from 'splaytree';\nimport {samePoint, getIntersectionXPoint} from './geom'\n\n/**\n * Creates a new sweep status data structure.\n */\nexport default function createSweepStatus(onError, EPS) {\n  var lastPointY, prevY;\n  var lastPointX, prevX;\n  var useBelow = false;\n  var status = new SplayTree(compareSegments);\n\n  // To save on GC we return mutable object.\n  var currentBoundary = {\n    beforeLeft: null,\n    left: null,\n    right: null,\n    afterRight: null,\n  }\n\n  var currentLeftRight = {left: null, right: null};\n\n  return {\n    /**\n     * Add new segments into the status tree.\n     */\n    insertSegments,\n\n    /**\n     * Remove segments from the status tree.\n     */\n    deleteSegments,\n\n    /**\n     * Returns segments that are to the left and right from a given point.\n     */\n    getLeftRightPoint,\n\n    /**\n     * For a given collections of segments finds the most left and the most right\n     * segments. Also returns segments immediately before left, and after right segments.\n     */\n    getBoundarySegments,\n\n    findSegmentsWithPoint,\n\n    /**\n     * Current binary search tree with segments\n     */\n    status,\n\n    /**\n     * Introspection method that verifies if there are duplicates in the segment tree.\n     * If there are - `onError()` is called.\n     */\n    checkDuplicate,\n\n    /**\n     * Prints current segments in order of their intersection with sweep line. Introspection method.\n     */\n    printStatus,\n\n    /**\n     * Returns current position of the sweep line.\n     */\n    getLastPoint() {\n      return {x: lastPointX, y: lastPointY};\n    }\n  }\n\n  function compareSegments(a, b) {\n    if (a === b) return 0;\n\n    var ak = getIntersectionXPoint(a, lastPointX, lastPointY);\n    var bk = getIntersectionXPoint(b, lastPointX, lastPointY);\n\n    var res = ak - bk;\n    if (Math.abs(res) >= EPS) {\n      // We are okay fine. Intersection distance between two segments\n      // is good to give conclusive answer\n      return res;\n    }\n\n    var aIsHorizontal = Math.abs(a.dy) < EPS;\n    var bIsHorizontal = Math.abs(b.dy) < EPS;\n    if (aIsHorizontal && bIsHorizontal) {\n      return b.to.x - a.to.x;\n    }\n    // TODO: What if both a and b is horizontal?\n    // move horizontal to end\n    if (aIsHorizontal) { \n      return useBelow ? -1 : 1;\n    }\n\n    if (bIsHorizontal) {\n      if (useBelow) {\n        return (b.from.x >= lastPointX) ? -1 : 1\n      }\n      return -1;\n      // return useBelow ? 1 : -1;\n    }\n    var pa = a.angle;\n    var pb = b.angle;\n    if (Math.abs(pa - pb) >= EPS) {\n      return useBelow ? pa - pb : pb - pa;\n    }\n\n    var segDist = a.from.y - b.from.y;\n    if (Math.abs(segDist) >= EPS) {\n      return -segDist;\n    }\n    segDist = a.to.y - b.to.y;\n    if (Math.abs(segDist) >= EPS) {\n      // TODO: Is this accurate?\n      return -segDist;\n    }\n\n    return 0;\n    // Could also use:\n    // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);\n    // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);\n    // return useBelow ? bAngle - aAngle : aAngle - bAngle;\n  }\n\n  function getBoundarySegments(upper, interior) {\n    var leftMost, rightMost, i;\n    var uLength = upper.length;\n\n    if (uLength > 0) {\n      leftMost = rightMost = upper[0];\n    } else {\n      leftMost = rightMost = interior[0];\n    }\n\n    for (i = 1; i < uLength; ++i) {\n      var s = upper[i];\n      var cmp = compareSegments(leftMost, s);\n      if (cmp > 0) leftMost = s;\n\n      cmp = compareSegments(rightMost, s);\n      if (cmp < 0) rightMost = s;\n    }\n\n    var startFrom = uLength > 0 ? 0 : 1;\n    for (i = startFrom; i < interior.length; ++i) {\n      s = interior[i];\n      cmp = compareSegments(leftMost, s);\n      if (cmp > 0) leftMost = s;\n\n      cmp = compareSegments(rightMost, s);\n      if (cmp < 0) rightMost = s;\n    }\n\n    // at this point we have our left/right segments in the status.\n    // Let's find their prev/next elements and report them back:\n    var left = status.find(leftMost);\n    if (!left) {\n      onError('Left is missing. Precision error?');\n    }\n\n    var right = status.find(rightMost);\n    if (!right) {\n      onError('Right is missing. Precision error?');\n    }\n\n    var beforeLeft = left && status.prev(left);\n    var afterRight = right && status.next(right);\n\n    while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {\n      // horizontal segments are special :(\n      afterRight = status.next(afterRight);\n    }\n\n    currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;\n    currentBoundary.left = left && left.key;\n    currentBoundary.right = right && right.key;\n    currentBoundary.afterRight = afterRight && afterRight.key;\n\n    return currentBoundary;\n  }\n\n  function getLeftRightPoint(p) {\n    // We are trying to find left and right segments that are nearest to the\n    // point p. For this we traverse the binary search tree, and remember\n    // node with the shortest distance to p.\n    var lastLeft;\n    var current = status._root;\n    var minX = Number.POSITIVE_INFINITY;\n\n    var useNext = false;\n    while (current) {\n      var x = getIntersectionXPoint(current.key, p.x, p.y);\n      var dx = p.x - x;\n      if (dx >= 0) {\n        if (dx < minX) {\n          minX = dx;\n          lastLeft = current;\n          current = current.left;\n          useNext = false;\n        } else {\n          break;\n        }\n      } else {\n        if (-dx < minX) {\n          useNext = true;\n          minX = -dx;\n          lastLeft = current;\n          current = current.right;\n        } else {\n          break;\n        }\n      }\n    }\n    if (useNext) {\n      // I'm not sure why I did this. I don't this this is right now.\n      // lastLeft = status.next(lastLeft);\n    }\n\n    currentLeftRight.left = lastLeft && lastLeft.key\n    var next = lastLeft && status.next(lastLeft);\n    currentLeftRight.right = next && next.key\n    return currentLeftRight;\n\n    // Conceptually, the code above should be equivalent to the code below;\n    // The code below is easier to understand, but intuitively, the code above\n    // should have better performance (as we do not traverse the entire status\n    // tree)\n\n    // var right, left,  x;\n    // var all = status.keys()\n    // for (var i = 0; i < all.length; ++i) {\n    //   var segment = all[i];\n    //   x = getIntersectionXPoint(segment, p.x, p.y);\n    //   if (x > p.x && !right) {\n    //     right = segment;\n    //     break;\n    //   } else if (x < p.x) {\n    //     left = segment;\n    //   }\n    // }\n\n    // currentLeftRight.left = left;\n    // currentLeftRight.right = right;\n\n    // return currentLeftRight;\n  }\n\n  function findSegmentsWithPoint(p, onFound) {\n    // Option 1.\n    // var arrResults = [];\n    // status.forEach(current => {\n    //   var x = getIntersectionXPoint(current.key, p.x, p.y);\n    //   var dx = p.x - x;\n    //   if (Math.abs(dx) < EPS) {\n    //     onFound(current.key);\n    //    // arrResults.push(current.key)\n    //   }\n    // });\n    // return arrResults;\n\n    // Option 2.\n\n    // let current = status._root;\n    // const Q = [];  /* Initialize stack s */\n    // let done = false;\n    // var res = [];\n    // var breakEarly = false;\n\n    // while (!done) {\n    //   if (current !==  null) {\n    //     Q.push(current);\n    //     current = current.left;\n    //   } else {\n    //     if (Q.length !== 0) {\n    //       current = Q.pop();\n\n    //       var x = getIntersectionXPoint(current.key, p.x, p.y);\n    //       var dx = p.x - x;\n    //       if (Math.abs(dx) < EPS) {\n    //         res.push(current.key)\n    //         breakEarly = true;\n    //       } else if (breakEarly) {\n    //         done = true;\n    //       }\n\n    //       current = current.right;\n    //     } else done = true;\n    //   }\n    // }\n\n    // return res;\n\n    // option 3.\n    var current = status._root;\n\n    while (current) {\n      var x = getIntersectionXPoint(current.key, p.x, p.y);\n      var dx = p.x - x;\n      if (Math.abs(dx) < EPS) {\n        collectAdjacentNodes(current, p, onFound);\n        break;\n      } else if (dx < 0) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n  }\n\n  function collectAdjacentNodes(root, p, onFound) {\n    onFound(root.key);\n    goOverPredecessors(root.left, p, onFound);\n    goOverSuccessors(root.right, p, onFound);\n  }\n\n  function goOverPredecessors(root, p, res) {\n    if (!root) return;\n    var x = getIntersectionXPoint(root.key, p.x, p.y);\n    var dx = p.x - x;\n    if (Math.abs(dx) < EPS) {\n      collectAdjacentNodes(root, p, res);\n    } else {\n      goOverPredecessors(root.right, p, res);\n    }\n  }\n\n  function goOverSuccessors(root, p, res) {\n    if (!root) return;\n    var x = getIntersectionXPoint(root.key, p.x, p.y);\n    var dx = p.x - x;\n    if (Math.abs(dx) < EPS) {\n      collectAdjacentNodes(root, p, res);\n    } else {\n      goOverSuccessors(root.left, p, res);\n    }\n  }\n\n  function checkDuplicate() {\n    var prev;\n    status.forEach(node => {\n      var current = node.key;\n\n      if (prev) {\n        if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {\n          // Likely you have received error before during segment removal.\n          onError('Duplicate key in the status! This may be caused by Floating Point rounding error')\n        }\n      }\n      prev = current;\n    });\n  }\n\n  function printStatus(prefix = '') {\n    // eslint-disable-next-line\n    console.log(prefix, 'status line: ', lastPointX, lastPointY);\n    status.forEach(node => {\n      var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);\n      // eslint-disable-next-line\n      console.log(x + ' ' + node.key.name);\n    })\n  }\n\n  function insertSegments(interior, upper, sweepLinePos) {\n    lastPointY = sweepLinePos.y;\n    lastPointX = sweepLinePos.x;\n    var key;\n\n    for (var i = 0; i < interior.length; ++i) {\n      key = interior[i];\n      status.add(key);\n    }\n    for (i = 0; i < upper.length; ++i) {\n      key = upper[i]\n      status.add(key);\n    }\n  }\n\n  function deleteSegments(lower, interior, sweepLinePos) {\n    // I spent most of the time debugging this method. Depending on the\n    // algorithm state we can run into situation when dynamic keys of the\n    // `status` tree predict wrong branch, and thus we are not able to find\n    // the segment that needs to be deleted. If that happens I'm trying to\n    // use previous point and repeat the process. This may result in \n    // incorrect state. In that case I report an error. \n    var i;\n    var prevCount = status._size;\n    prevX = lastPointX;\n    prevY = lastPointY;\n    lastPointY = sweepLinePos.y;\n    lastPointX = sweepLinePos.x;\n\n    useBelow = true;\n    for(i = 0; i < lower.length; ++i) {\n      removeSegment(lower[i], sweepLinePos)\n    }\n    for(i = 0; i < interior.length; ++i) {\n      removeSegment(interior[i], sweepLinePos)\n    }\n    useBelow = false;\n\n    if (status._size !== prevCount - interior.length - lower.length) {\n      // This can happen when rounding error occurs. You can try scaling your input\n      onError('Segments were not removed from a tree properly. Precision error?');\n    }\n  }\n\n  function removeSegment(key, sweepLinePos) {\n    if (status.find(key)) {\n      status.remove(key);\n    } else {\n      lastPointX = prevX;\n      lastPointY = prevY;\n      if (status.find(key)) {\n        status.remove(key);\n      } else {\n        // They will get an error :(\n      }\n      lastPointY = sweepLinePos.y;\n      lastPointX = sweepLinePos.x;\n    }\n  }\n}","/**\n * Represents a single event in the sweep-line algorithm\n */\nexport default class SweepEvent {\n  /**\n   * Creates new sweep event of a given kind.\n   */\n  constructor(point, segment) {\n    this.point = point;\n    if (segment) this.from = [segment];\n  }\n}\n","import createEventQueue from './src/createEventQueue';\nimport createSweepStatus from './src/sweepStatus';\nimport SweepEvent from './src/SweepEvent';\n\nimport {intersectSegments, EPS, angle, samePoint} from './src/geom';\n\n/**\n * A point on a line\n * \n * @typedef {Object} Point\n * @property {number} x coordinate\n * @property {number} y coordinate\n */\n\n\n/**\n * @typedef {Object} Segment \n * @property {Point} from start of the segment\n * @property {Point} to end of the segment\n */\n\n/**\n * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback\n */\n\n/**\n * @typedef {Object} ISectOptions \n * @property {ReportIntersectionCallback} onFound \n */\n\n /**\n  * @typedef {Object} ISectResult\n  */\n\n// We use EMPTY array to avoid pressure on garbage collector. Need to be\n// very cautious to not mutate this array.\nvar EMPTY = [];\n\n/**\n * Finds all intersections among given segments.\n * \n * The algorithm follows \"Computation Geometry, Algorithms and Applications\" book\n * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.\n * \n * Line is swept top-down\n * \n * @param {Segment[]} segments\n * @param {ISectOptions=} options\n * @returns {ISectResult}\n */\nexport default function isect(segments, options) {\n  var results = [];\n  var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;\n\n  var onError = (options && options.onError) || defaultErrorReporter;\n\n  var eventQueue = createEventQueue(byY);\n  var sweepStatus = createSweepStatus(onError, EPS);\n  var lower, interior, lastPoint;\n\n  segments.forEach(addSegment);\n\n  return {\n    /**\n     * Find all intersections synchronously.\n     * \n     * @returns array of found intersections.\n     */\n    run,\n\n    /**\n     * Performs a single step in the sweep line algorithm\n     * \n     * @returns true if there was something to process; False if no more work to do\n     */\n    step,\n\n    // Methods below are low level API for fine-grained control.\n    // Don't use it unless you understand this code thoroughly\n\n    /**\n     * Add segment into the \n     */\n    addSegment,\n\n    /**\n     * Direct access to event queue. Queue contains segment endpoints and\n     * pending detected intersections.\n     */\n    eventQueue, \n\n    /**\n     * Direct access to sweep line status. \"Status\" holds information about\n     * all intersected segments.\n     */\n    sweepStatus,\n\n    /**\n     * Access to results array. Works only when you use default onFound() handler\n     */\n    results\n  }\n\n  function run() {\n    while (!eventQueue.isEmpty()) {\n      var eventPoint = eventQueue.pop();\n      if (handleEventPoint(eventPoint)) {\n        // they decided to stop.\n        return;\n      };\n    }\n\n    return results;\n  }\n\n  function step() {\n    if (!eventQueue.isEmpty()) {\n      var eventPoint = eventQueue.pop();\n      handleEventPoint(eventPoint);\n      // Note: we don't check results of `handleEventPoint()`\n      // assumption is that client controls `step()` and thus they \n      // know better if they want to stop.\n      return true;\n    }\n    return false;\n  }\n\n  function handleEventPoint(p) {\n    lastPoint = p.point;\n    var upper = p.from || EMPTY;\n\n    lower = interior = undefined;\n    // TODO: move lower/interior into sweep status method?\n\n    sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);\n    // if (segmentsWithPoint) {\n    //   segmentsWithPoint.forEach()\n    // } \n\n    if (!lower) lower = EMPTY;\n    if (!interior) interior = EMPTY;\n\n    var uLength = upper.length;\n    var iLength = interior.length;\n    var lLength = lower.length;\n    var hasIntersection = uLength + iLength + lLength > 1;\n    var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);\n\n    if (hasIntersection || hasPointIntersection) {\n      p.isReported = true;\n      if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {\n        return true;\n      }\n    }\n\n    sweepStatus.deleteSegments(lower, interior, lastPoint);\n    sweepStatus.insertSegments(interior, upper, lastPoint);\n\n    var sLeft, sRight;\n\n    var hasNoCrossing = (uLength + iLength === 0);\n\n    if (hasNoCrossing) {\n      var leftRight = sweepStatus.getLeftRightPoint(lastPoint);\n      sLeft = leftRight.left;\n      if (!sLeft) return;\n\n      sRight = leftRight.right;\n      if (!sRight) return;\n\n      findNewEvent(sLeft, sRight, p);\n    } else {\n      var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);\n\n      findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);\n      findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);\n    }\n\n    return false;\n  }\n\n  function addLowerOrInterior(s) {\n    if (samePoint(s.to, lastPoint)) {\n      if (!lower) lower = [s];\n      else lower.push(s);\n    } else if (!samePoint(s.from, lastPoint)) {\n      if (!interior) interior = [s];\n      else interior.push(s);\n    }\n  }\n\n  function findNewEvent(left, right, p) {\n    if (!left || !right) return;\n\n    var intersection = intersectSegments(left, right);\n    if (!intersection) {\n        return;\n    }\n\n    var dy = p.point.y - intersection.y\n    // TODO: should I add dy to intersection.y?\n    if (dy < -EPS) {\n      // this means intersection happened after the sweep line. \n      // We already processed it.\n      return;\n    }\n    if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {\n      return;\n    }\n\n    // Need to adjust floating point for this special case,\n    // since otherwise it gives rounding errors:\n    roundNearZero(intersection);\n\n    var current = eventQueue.find(intersection);\n\n    if (current && current.isReported) {\n      // We already reported this event. No need to add it one more time\n      // TODO: Is this case even possible?\n      onError('We already reported this event.');\n      return;\n    }\n\n    if (!current) {\n      var event = new SweepEvent(intersection)\n      eventQueue.insert(event);\n    }\n  }\n\n  function defaultIntersectionReporter(p, segments) {\n    results.push({\n      point: p, \n      segments: segments\n    });\n  }\n\n  function addSegment(segment) {\n    var from = segment.from;\n    var to = segment.to;\n\n    // Small numbers give more precision errors. Rounding them to 0.\n    roundNearZero(from);\n    roundNearZero(to);\n\n    var dy = from.y - to.y;\n\n    // Note: dy is much smaller then EPS on purpose. I found that higher\n    // precision here does less good - getting way more rounding errors.\n    if (Math.abs(dy) < 1e-5) {\n      from.y = to.y;\n      segment.dy = 0;\n    }\n    if ((from.y < to.y) || (\n        (from.y === to.y) && (from.x > to.x))\n      ) {\n      var temp = from;\n      from = segment.from = to; \n      to = segment.to = temp;\n    }\n\n    // We pre-compute some immutable properties of the segment\n    // They are used quite often in the tree traversal, and pre-computation\n    // gives significant boost:\n    segment.dy = from.y - to.y;\n    segment.dx = from.x - to.x;\n    segment.angle = angle(segment.dy, segment.dx);\n\n    var isPoint = segment.dy === segment.dx && segment.dy === 0;\n    var prev = eventQueue.find(from)\n    if (prev && !isPoint) {\n      // this detects identical segments early. Without this check\n      // the algorithm would break since sweep line has no means to\n      // detect identical segments.\n      var prevFrom = prev.data.from;\n      if (prevFrom) {\n        for (var i = 0; i < prevFrom.length; ++i) {\n          var s = prevFrom[i];\n          if (samePoint(s.to, to)) {\n            reportIntersection(s.from, [s.from, s.to]);\n            reportIntersection(s.to, [s.from, s.to]);\n            return;\n          }\n        }\n      }\n    }\n\n    if (!isPoint) {\n      if (prev) {\n        if (prev.data.from) prev.data.from.push(segment);\n        else prev.data.from = [segment];\n      } else {\n        var e = new SweepEvent(from, segment)\n        eventQueue.insert(e);\n      }\n      var event = new SweepEvent(to)\n      eventQueue.insert(event)\n    } else {\n      var event = new SweepEvent(to)\n      eventQueue.insert(event)\n    }\n  } \n}\n\nfunction roundNearZero(point) {\n  if (Math.abs(point.x) < EPS) point.x = 0;\n  if (Math.abs(point.y) < EPS) point.y = 0;\n}\n\nfunction defaultErrorReporter(errorMessage) {\n  throw new Error(errorMessage);\n}\n\nfunction union(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n\n  return a.concat(b);\n}\n\nfunction byY(a, b) {\n  // decreasing Y \n  var res = b.y - a.y;\n  // TODO: This might mess up the status tree.\n  if (Math.abs(res) < EPS) {\n    // increasing x.\n    res = a.x - b.x;\n    if (Math.abs(res) < EPS) res = 0;\n  }\n\n  return res;\n}","export default function intersectSegments(a, b) {\n  // Note: this is almost the same as geom.intersectSegments()\n  // The main difference is that we don't have a pre-computed\n  // value for dx/dy on the segments.\n  //  https://stackoverflow.com/a/1968345/125351\n  var aStart = a.from, bStart = b.from;\n  var p0_x = aStart.x, p0_y = aStart.y,\n      p2_x = bStart.x, p2_y = bStart.y;\n\n  var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;\n  var div = s1_x * s2_y - s2_x * s1_y;\n\n  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;\n  if (s < 0 || s > 1) return;\n\n  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;\n\n  if (t >= 0 && t <= 1) {\n    return {\n      x: p0_x - (t * s1_x),\n      y: p0_y - (t * s1_y)\n    }\n  }\n}","\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\nconst VERSION = 3; // serialized format version\n\nexport default class Flatbush {\n\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xfb) {\n            throw new Error('Data does not appear to be in a Flatbush format.');\n        }\n        if (versionAndType >> 4 !== VERSION) {\n            throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);\n    }\n\n    constructor(numItems, nodeSize, ArrayType, data) {\n        if (numItems === undefined) throw new Error('Missing required argument: numItems.');\n        if (isNaN(numItems) || numItems <= 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);\n\n        // calculate the total number of nodes in the R-tree to allocate space for\n        // and the index of each tree level (used in search later)\n        let n = numItems;\n        let numNodes = n;\n        this._levelBounds = [n * 4];\n        do {\n            n = Math.ceil(n / this.nodeSize);\n            numNodes += n;\n            this._levelBounds.push(numNodes * 4);\n        } while (n !== 1);\n\n        this.ArrayType = ArrayType || Float64Array;\n        this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) {\n            this.data = data;\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n\n            this._pos = numNodes * 4;\n            this.minX = this._boxes[this._pos - 4];\n            this.minY = this._boxes[this._pos - 3];\n            this.maxX = this._boxes[this._pos - 2];\n            this.maxY = this._boxes[this._pos - 1];\n\n        } else {\n            this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n            this._pos = 0;\n            this.minX = Infinity;\n            this.minY = Infinity;\n            this.maxX = -Infinity;\n            this.maxY = -Infinity;\n\n            new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    add(minX, minY, maxX, maxY) {\n        const index = this._pos >> 2;\n        this._indices[index] = index;\n        this._boxes[this._pos++] = minX;\n        this._boxes[this._pos++] = minY;\n        this._boxes[this._pos++] = maxX;\n        this._boxes[this._pos++] = maxY;\n\n        if (minX < this.minX) this.minX = minX;\n        if (minY < this.minY) this.minY = minY;\n        if (maxX > this.maxX) this.maxX = maxX;\n        if (maxY > this.maxY) this.maxY = maxY;\n    }\n\n    finish() {\n        if (this._pos >> 2 !== this.numItems) {\n            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n        }\n\n        const width = this.maxX - this.minX;\n        const height = this.maxY - this.minY;\n        const hilbertValues = new Uint32Array(this.numItems);\n        const hilbertMax = (1 << 16) - 1;\n\n        // map item centers into Hilbert coordinate space and calculate Hilbert values\n        for (let i = 0; i < this.numItems; i++) {\n            let pos = 4 * i;\n            const minX = this._boxes[pos++];\n            const minY = this._boxes[pos++];\n            const maxX = this._boxes[pos++];\n            const maxY = this._boxes[pos++];\n            const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n            const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n            hilbertValues[i] = hilbert(x, y);\n        }\n\n        // sort items by their Hilbert value (for packing later)\n        sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);\n\n        // generate nodes at each tree level, bottom-up\n        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n            const end = this._levelBounds[i];\n\n            // generate a parent node for each block of consecutive <nodeSize> nodes\n            while (pos < end) {\n                let nodeMinX = Infinity;\n                let nodeMinY = Infinity;\n                let nodeMaxX = -Infinity;\n                let nodeMaxY = -Infinity;\n                const nodeIndex = pos;\n\n                // calculate bbox for the new node\n                for (let i = 0; i < this.nodeSize && pos < end; i++) {\n                    const minX = this._boxes[pos++];\n                    const minY = this._boxes[pos++];\n                    const maxX = this._boxes[pos++];\n                    const maxY = this._boxes[pos++];\n                    if (minX < nodeMinX) nodeMinX = minX;\n                    if (minY < nodeMinY) nodeMinY = minY;\n                    if (maxX > nodeMaxX) nodeMaxX = maxX;\n                    if (maxY > nodeMaxY) nodeMaxY = maxY;\n                }\n\n                // add the new node to the tree data\n                this._indices[this._pos >> 2] = nodeIndex;\n                this._boxes[this._pos++] = nodeMinX;\n                this._boxes[this._pos++] = nodeMinY;\n                this._boxes[this._pos++] = nodeMaxX;\n                this._boxes[this._pos++] = nodeMaxY;\n            }\n        }\n    }\n\n    search(minX, minY, maxX, maxY, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        let nodeIndex = this._boxes.length - 4;\n        let level = this._levelBounds.length - 1;\n        const queue = [];\n        const results = [];\n\n        while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, this._levelBounds[level]);\n\n            // search through child nodes\n            for (let pos = nodeIndex; pos < end; pos += 4) {\n                const index = this._indices[pos >> 2];\n\n                // check if node bbox intersects with query bbox\n                if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX\n                if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY\n                if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX\n                if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY\n\n                if (nodeIndex < this.numItems * 4) {\n                    if (filterFn === undefined || filterFn(index)) {\n                        results.push(index); // leaf item\n                    }\n\n                } else {\n                    queue.push(index); // node; add it to the search queue\n                    queue.push(level - 1);\n                }\n            }\n\n            level = queue.pop();\n            nodeIndex = queue.pop();\n        }\n\n        return results;\n    }\n}\n\n// custom quicksort that sorts bbox data alongside the hilbert values\nfunction sort(values, boxes, indices, left, right) {\n    if (left >= right) return;\n\n    const pivot = values[(left + right) >> 1];\n    let i = left - 1;\n    let j = right + 1;\n\n    while (true) {\n        do i++; while (values[i] < pivot);\n        do j--; while (values[j] > pivot);\n        if (i >= j) break;\n        swap(values, boxes, indices, i, j);\n    }\n\n    sort(values, boxes, indices, left, j);\n    sort(values, boxes, indices, j + 1, right);\n}\n\n// swap two values and two corresponding boxes\nfunction swap(values, boxes, indices, i, j) {\n    const temp = values[i];\n    values[i] = values[j];\n    values[j] = temp;\n\n    const k = 4 * i;\n    const m = 4 * j;\n\n    const a = boxes[k];\n    const b = boxes[k + 1];\n    const c = boxes[k + 2];\n    const d = boxes[k + 3];\n    boxes[k] = boxes[m];\n    boxes[k + 1] = boxes[m + 1];\n    boxes[k + 2] = boxes[m + 2];\n    boxes[k + 3] = boxes[m + 3];\n    boxes[m] = a;\n    boxes[m + 1] = b;\n    boxes[m + 2] = c;\n    boxes[m + 3] = d;\n\n    const e = indices[i];\n    indices[i] = indices[j];\n    indices[j] = e;\n}\n\n// Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n// Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\nfunction hilbert(x, y) {\n    let a = x ^ y;\n    let b = 0xFFFF ^ a;\n    let c = 0xFFFF ^ (x | y);\n    let d = x & (y ^ 0xFFFF);\n\n    let A = a | (b >> 1);\n    let B = (a >> 1) ^ a;\n    let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\n    let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 2)) ^ (b & (b >> 2)));\n    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\n    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\n    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 4)) ^ (b & (b >> 4)));\n    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\n    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\n    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\n\n    a = A; b = B; c = C; d = D;\n    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\n    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\n\n    a = C ^ (C >> 1);\n    b = D ^ (D >> 1);\n\n    let i0 = x ^ y;\n    let i1 = b | (0xFFFF ^ (i0 | a));\n\n    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\n    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\n    i0 = (i0 | (i0 << 2)) & 0x33333333;\n    i0 = (i0 | (i0 << 1)) & 0x55555555;\n\n    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\n    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\n    i1 = (i1 | (i1 << 2)) & 0x33333333;\n    i1 = (i1 | (i1 << 1)) & 0x55555555;\n\n    return ((i1 << 1) | i0) >>> 0;\n}\n","import SplayTree from 'splaytree';\n\nexport default function createEventQueue(byY) {\n  const q = new SplayTree(byY);\n\n  return {\n    isEmpty: isEmpty,\n    size: size,\n    pop: pop,\n    find: find,\n    insert: insert\n  }\n\n  function find(p) {\n    return q.find(p);\n  }\n\n  function size() {\n    return q.size;\n  }\n\n  function isEmpty() {\n    return q.isEmpty();\n  }\n\n  function insert(event) {\n    // debugger;\n    q.add(event.point, event);\n  }\n\n  function pop() {\n    var node = q.pop();\n    return node && node.data;\n  }\n}\n","import intersectSegments from './src/intersectSegments';\n\n/**\n * This is a brute force solution with O(n^2) performance.\n * (`n` is number of segments).\n * \n * Use this when number of lines is low, and number of intersections\n * is high.\n */\nexport default function brute(lines, options) {\n  var results = [];\n  var reportIntersection = (options && options.onFound) || \n                            defaultIntersectionReporter;\n  var asyncState;\n\n  return {\n    /**\n     * Execute brute force of the segment intersection search\n     */\n    run,\n    /**\n     * Access to results array. Works only when you use default onFound() handler\n     */\n    results,\n\n    /**\n     * Performs a single step in the brute force algorithm ()\n     */\n    step\n  }\n\n  function step() {\n    if (!asyncState) {\n      asyncState = {\n        i: 0\n      }\n    }\n    var test = lines[asyncState.i];\n    for (var j = asyncState.i + 1; j < lines.length; ++j) {\n      var other = lines[j];\n      var pt = intersectSegments(test, other);\n      if (pt) {\n        if (reportIntersection(pt, [test, other])) {\n          return;\n        }\n      }\n    }\n    asyncState.i += 1;\n    return asyncState.i < lines.length;\n  }\n\n  function run() {\n    for(var i = 0; i < lines.length; ++i) {\n      var test = lines[i];\n      for (var j = i + 1; j < lines.length; ++j) {\n        var other = lines[j];\n        var pt = intersectSegments(test, other);\n        if (pt) {\n          if (reportIntersection(pt, [test, other])) {\n            return;\n          }\n        }\n      }\n    }\n    return results;\n  }\n\n  function defaultIntersectionReporter(p, interior) {\n    results.push({\n      point: p, \n      segments: interior\n    });\n  }\n}","import Flatbush from 'flatbush';\nimport intersectSegments from './src/intersectSegments';\n\n/**\n * This implementation is inspired by discussion here \n * https://twitter.com/mourner/status/1049325199617921024 and \n * here https://github.com/anvaka/isect/issues/1\n * \n * It builds an index of all segments using static spatial index\n * and then for each segment it queries overlapping rectangles.\n */\nexport default function bush(lines, options) {\n  var results = [];\n  var reportIntersection = (options && options.onFound) || \n                            defaultIntersectionReporter;\n  var asyncState;\n\n  var index = new Flatbush(lines.length);\n  lines.forEach(addToIndex);\n  index.finish();\n\n  return {\n    run: run,\n    step: step,\n    results: results,\n\n    // undocumented, don't use unless you know what you are doing:\n    checkIntersection: checkIntersection\n  }\n\n  function run() {\n    for (var i = 0; i < lines.length; ++i) {\n      if (checkIntersection(lines[i], i)) {\n        return; // stop early\n      }\n    }\n    return results;\n  }\n\n  function checkIntersection(currentSegment, currentId) {\n    // sorry about code duplication.\n    var minX = currentSegment.from.x; var maxX = currentSegment.to.x;\n    var minY = currentSegment.from.y; var maxY = currentSegment.to.y;\n    var t;\n    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }\n    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }\n\n    var ids = index.search(minX, minY, maxX, maxY);\n\n    for (var i = 0; i < ids.length; ++i) {\n      var segmentIndex = ids[i];\n      if (segmentIndex <= currentId) continue; // we have either reported it, or it is current.\n\n      var otherSegment = lines[segmentIndex];\n      var point = intersectSegments(otherSegment, currentSegment);\n\n      if (point) {\n        if (reportIntersection(point, [currentSegment, otherSegment])) {\n          // stop early\n          return true;\n        }\n      }\n    }\n  }\n\n  function step() {\n    if (!asyncState) {\n      asyncState = {i: 0};\n    }\n    var test = lines[asyncState.i];\n    checkIntersection(test, asyncState.i);\n    asyncState.i += 1;\n    return asyncState.i < lines.length;\n  }\n\n\n  function addToIndex(line) {\n    var minX = line.from.x; var maxX = line.to.x;\n    var minY = line.from.y; var maxY = line.to.y;\n    var t;\n    if (minX > maxX) { t = minX; minX = maxX; maxX = t; }\n    if (minY > maxY) { t = minY; minY = maxY; maxY = t; }\n    index.add(minX, minY, maxX, maxY);\n  }\n\n  function defaultIntersectionReporter(p, interior) {\n    results.push({\n      point: p, \n      segments: interior\n    });\n  }\n}"],"names":["Node","key","data","this","left","right","DEFAULT_COMPARE","a","b","splay","i","t","comparator","let","l","r","y","N","const","cmp","insert","tree","node","_size","remove","x","split","v","Tree","_comparator","_root","add","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","length","call","range","low","high","fn","keys","ref","values","min","minNode","max","maxNode","at","index","next","d","root","successor","prev","predecessor","clear","toList","head","p","load","presort","size","sort","pivot","j","tmp","loadRecursive","parent","start","end","middle","Math","floor","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","list","isEmpty","prototypeAccessors","toString","printNode","n","out","printRow","prefix","isTail","indent","join","update","newKey","newData","EPS","getIntersectionXPoint","segment","xPos","yPos","dy1","from","dy2","to","dy","abs","xOffset","dx","samePoint","createSweepStatus","onError","lastPointY","prevY","lastPointX","prevX","useBelow","status","SplayTree","compareSegments","currentBoundary","beforeLeft","afterRight","currentLeftRight","interior","upper","sweepLinePos","lower","prevCount","removeSegment","lastLeft","minX","Number","POSITIVE_INFINITY","leftMost","rightMost","uLength","s","onFound","collectAdjacentNodes","console","log","name","getLastPoint","res","aIsHorizontal","bIsHorizontal","pa","angle","pb","segDist","goOverPredecessors","goOverSuccessors","SweepEvent","point","EMPTY","roundNearZero","defaultErrorReporter","errorMessage","Error","union","concat","byY","intersectSegments","aStart","bStart","p0_x","p0_y","p2_x","p2_y","s1_x","s1_y","s2_x","s2_y","div","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Flatbush","numItems","nodeSize","ArrayType","undefined","isNaN","numNodes","_levelBounds","ceil","IndexArrayType","arrayTypeIndex","indexOf","nodesByteSize","BYTES_PER_ELEMENT","ArrayBuffer","_boxes","_indices","_pos","minY","maxX","maxY","Infinity","set","swap","boxes","indices","temp","k","m","c","e","hilbert","A","B","C","D","i0","i1","magic","versionAndType","finish","width","height","hilbertValues","pos","nodeMinX","nodeMinY","nodeMaxX","nodeMaxY","nodeIndex","this$1","search","filterFn","level","queue","results","segments","options","q","lastPoint","reportIntersection","eventQueue","event","sweepStatus","addSegment","eventPoint","handleEventPoint","findSegmentsWithPoint","addLowerOrInterior","sLeft","sRight","iLength","lLength","hasIntersection","isReported","deleteSegments","insertSegments","leftRight","getLeftRightPoint","findNewEvent","boundarySegments","getBoundarySegments","intersection","isPoint","prevFrom","lines","asyncState","test","other","pt","line","run","checkIntersection","step","currentSegment","currentId","ids","segmentIndex","otherSegment"],"mappings":"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"}